\chapter{Conclusion}\label{sec:conclusion}

The results that are in line with the results from the ones for static bound unrolling~\cite{aebi18bachelorarbeit}, and therefore strongly suggest, that there is now empirical evidence that independent of the factor chosen loop unrolling does not yield a significant performance benefit in the current state of~\libFIRM.
Even though through the added loop optimization, more loops were able to be unrolled, the increase in unrollability was significantly less than predicted in the preliminary hypothesis, which certainly is a contributing factor to the underwhelming improvements.
Probably some restrictions, such as disallowing \texttt{break}-like structures, are too limited and could be dealt with through further development.
Other restrictions, such as the conservative alias, or call manipulation, checks for the bound are unavoidable if the semantics are to be kept and forthright inherent to the task at hand.
Inconsiderate of these reasons, the eminent challenge seems to be the lack of performance gain through unrolling loops.
Further, it can be concluded that the choice of the fixup code strategy seems to have a neglectable impact on performance.
Though this hypothesis should be reevaluated, if there are changes done, such that loop unrolling becomes a viable choice for optimizing code using~\libFIRM.
Due to the very low standard deviations across all benchmarks, this work also leads to a firm belief, the obtained results are trustable and hence provide a solid foundation for empirical conclusions, like the ones drawn above.

Further, loop unrolling alone, never (significantly) improves execution times without other optimizations improving the unrolled code.
Through the implicitly added semantics as for having a specific modulus, respective to $f$, for each unrolled block, an optimization could be created that takes advantage of this and could simplify mathematical operations.
Before this potential is used, the results strongly suggest that it would be a more lucrative endeavor, to stick to less fancy optimizations that can take advantage of the unrolled loop structures, such as potentially automatically parallelizing non-conflicting operations across $f$ threads.

The efforts of increasing unrollable loops seem to currently exceed the benefits, due to the lack of optimizations using unrolled loops.
For if the desire for more unroallability, should pick up again, once the optimization yields benefits, it would seem a good point, to look at other loop structures, such as loops with breaks, or a non-counting loop, unlike the ones examined in this thesis.
