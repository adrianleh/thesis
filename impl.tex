\chapter{Design and implementation}\label{sec:impl}

In order to unroll a loop with non-static bounds this thesis will be following the following approach:
First, we will check whether a loop can be unrolled.
\Cref{sec:impl:unrollability} describes the conditions necessary and how they are checked.
After that, \textit{fixup code}
\footnote{The term \textit{fixup code} describes that code that has to be added to account for cases where the number of times the loop is executed modulo the unrolling factor is not equal to zero.}
,as describe in \cref{sec:impl:fixup}, will be created, and the loop will be unrolled a set number of times and its header will be updated.
The unrolling process will be covered in \cref{sec:impl:unroll}.

In the following a convention will be used, where we will assume loops are like the loop in~\ref{fig:impl:general-loop}.
In \cref{fig:impl:general-loop} \textit{cmp} refers to a comparison that can be one of the following: $<, >, \geq, \leq$.
Further, $I \in \mathbb{Z}$ will refer to the starting value, $N \in \mathbb{Z}$ to the bound, and $c \in \mathbb{Z}$ to the increment\footnote{N.B.: $c$ may be negative and could hence also be a decrement} of such loop.

\input{fig/general-loop.tex}

\section{Determining unrollability}\label{sec:impl:unrollability}

\section{Unrolling}\label{sec:impl:unroll}

To get started with unrolling loops that have unknown bounds, we will unroll them with a given factor without considering whether the transformation is semantically invariant.
In \cref{sec:impl:fixup} and \cref{sec:impl:preheader} we will be restoring the semantic equivalence.

Since~\libFIRM~already provides an unrolling mechanism for unrolling a loop with a given factor~\cite{aebi18bachelorarbeit}, we will be using it to unroll our loop by a factor $f$.
\Cref{fig:impl:unroll:existing-mechanism} shows a summary of the way the mechanism works.
N.B.: The LCSSA property is preserved across all following operations.

Further, figures~\ref{fig:impl:unroll:unroll-factor-2-before} and,~\ref{fig:impl:unroll:unroll-factor-2-after} show a firm graph of a loop that is to be unrolled or is unrolled using a factor of two, respectively.
Especially to be noted is that in \cref{fig:impl:unroll:unroll-factor-2-after} the loop header is duplicated and that hence the number of conditions did not decrease through the loop unroll.
With the previous usage this was not an issue though, as using a constant bit analysis~\libFIRM~would automatically remove these excess headers~\cite{aebi18bachelorarbeit}.
Unfortunately though in the use cases of an unknown bound that of course does not work, as~\libFIRM~cannot recognize the additional semantics we are adding.
Henceforth, the need to manually prune the graph to remove the excess headers arises.
\Cref{alg:impl:unroll:prune-headers} shows the algorithm used to accomplish this.
First all phis in the header will be rewired, such that all in-loop nodes descending from any given phi node will each get the in-loop predecessesors of the phi node as predecessors themselves, whilst the phi node is no longer a predecessor of any of the descendants.
The same will then be done to the descendants of the block itself.

\input{fig/prune-header.tex}

\input{fig/alg-old-unrolling.tex}

\input{fig/plain-unrolling.tex}

\section{Fixup strategies}\label{sec:impl:fixup}

In \cref{sec:impl:unroll} the unrolling process is discussed.
That process is done without considering the fixup code needed.
In \cref{sec:impl:fixup:duff} a generalized version of duff's device will used to create the needed fixup, whereas in \cref{sec:impl:fixup:loop} a copy of the original loop.
Later we will evaluate, which approach yields faster binary runtimes.

\subsection{Generalized duff's device}\label{sec:impl:fixup:duff}

\subsection{Loop duplication}\label{sec:impl:fixup:loop}

\section{Updating the loop condition}\label{sec:impl:fixup:header-cond}

