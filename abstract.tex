\begin{abstract}
    \begin{center}
        \Huge\textbf{\textsf{Zusammenfassung}}
    \end{center}
    \vfill
    \begin{otherlanguage}{ngerman}
        Das Schleifenausrollen ist der Prozess, bei dem der Körper einer Schleife mehrfach dupliziert wird, um die Anzahl der bedingten Sprünge zu reduzieren.
        Während Schleifen mit konstanten Grenzen leicht ausgerollt werden können, erweist sich das Ausrollen von Schleifen mit nicht konstanten Grenzen als eine Herausforderung.

        Da man nicht wei\ss{}, wie oft ein Schleifenkörper augeführt wird, reicht es nicht aus diese mit einem statischen Faktor auszurollen.
        Allerdings ist es möglich spekulativ eine Schleife um einen bestimmten Faktor ausrollen.
        Es muss jedoch sichergestellt werden, dass die ausgerollte Schleife, zwar so oft wie möglich ausgeführt wird, jedoch immer weniger oder gleich oft wie die ursprüngliche Schleife läuft.
        Um die daraus resultierende Diskrepanz zu kompensieren, wird sogenannter Fixup-Code erstellt, welcher für die Ausführung der restlichen Iterationen verantwortlich ist.

        Bei der abschlie\ss{}enden experimentellen Bewertung des Ansatzes wird deutlich, dass das Schleifenausrollen ohne weitere Optimierung nicht sinnvoll ist, da sich keine Beschleunigung au\ss{}erhalb der Messtoleranz feststellen lässt.
    \end{otherlanguage}
    \vfill

    \begin{center}
        \Huge\textbf{\textsf{Abstract}}
    \end{center}
    \vfill
    Loop unrolling is the process of duplicating a loop's body multiple times in order to reduce the amount of conditional jumps.
    Whilst loops with constant bounds can be easily unrolled, unrolling loops with non constant bounds proves to be a different challenge.

    Since one does not know the amount of times a loop body unrolling with a static factor will not suffice.
    That said, we can speculatively unroll a loop by a given factor, whilst making sure that the unrolled loop while running as often as possible, always run less than or equal times to the original loop.
    In order to compensate for the hence resulting discrapancy, we create so called fixup code, which is responsible for running the remaining iterations.

    When expirementally evaluating the approach it becomes clear that without further optimization loop unrolling is not beneficial, as we cannot note any speed-up outside of margin of error.
\end{abstract}