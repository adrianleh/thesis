\chapter{Conclusion}\label{sec:conclusion}

The results, show in \cref{sec:eval:perf}, fall in line with the results from the ones for static bound unrolling~\cite{aebi18bachelorarbeit}, and therefore suggest, that there is now empirical evidence that independent of the unrolling method, and the factor chosen loop unrolling does not yield a significant performance benefit in the current state of~\libFIRM.
Unfortunately the evidence is tainted by the fact that we still only unroll approximately one in ten loops.
Even though through the added loop optimization, more loops were able to be unrolled, the increase in unrollability only led to about one in ten loops being unrolled, which certainly is a contributing factor to the underwhelming improvements.
Probably some restrictions, such as disallowing \texttt{break}-like structures, are too limited and could be dealt with through further development.
Other restrictions, such as the conservative alias, or call manipulation, checks for the bound are unavoidable if the semantics are to be kept and forthright inherent to the task at hand.
Inconsiderate of these reasons, the eminent challenge seems to be the lack of performance gain through unrolling loops.
Further, it can be concluded that the choice of the fixup code strategy seems to have a negligible impact on performance.
Though this hypothesis should be reevaluated, if there are changes done, such that loop unrolling becomes a viable choice for optimizing code using~\libFIRM.
Due to the very low standard deviations across all benchmarks, this work also leads to a firm belief the obtained results are trustable and hence provide a solid foundation for empirical conclusions, like the ones drawn above.

Further, loop unrolling alone, never (significantly) improves execution times without other optimizations improving the unrolled code.
Through the implicitly added semantics as for having a specific modulus, respective to $f$, for each unrolled block, an optimization could be created that takes advantage of this and could simplify mathematical operations.
Before this potential is used, the results strongly suggest that it would be a more lucrative endeavor, to stick to less fancy optimizations that can take advantage of the unrolled loop structures, such as potentially automatically parallelizing non-conflicting operations across $f$ threads.
Once this is completed the feasibility of loop unrolling should be reevaluated.

Another factor that might have influenced the results was the method used to determine the unroll-factor.
We used a very simple heurisitic that only accounted for the size of the loop once it is unrolled.
In the future it could be evaluated, whether the performance would improve through a more sophisticated unroll-factor selection, with a multi-parameter cost function.

The efforts of increasing unrollable loops seem to currently exceed the benefits, due to the required effort for minimal benefit.
For if the desire for more unroallability, should pick up again, once the optimization yields benefits, it would seem a good point, to look at other loop structures, such as loops with breaks, or a non-counting loop, unlike the ones examined in this thesis.
